<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Head Lasers Scroll Scene</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden; /* we "fake scroll" inside a container */
      background: #0b0b0f;
      color: white;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    /* A scroll container so we can control scrollTop ourselves */
    #scroll {
      position: fixed;
      inset: 0;
      overflow: hidden; /* no native scrolling */
    }
    #world {
      position: relative;
      height: 4000px; /* make it "scrollable" */
      width: 100%;
    }

    /* Optional: subtle moving background to sell "scrolling" */
    .stars {
      position: absolute;
      inset: 0;
      background:
        radial-gradient(circle at 20% 30%, rgba(255,255,255,.12), transparent 35%),
        radial-gradient(circle at 60% 70%, rgba(255,255,255,.10), transparent 40%),
        radial-gradient(circle at 80% 20%, rgba(255,255,255,.08), transparent 35%);
      filter: blur(0.2px);
      opacity: 0.8;
      pointer-events: none;
    }

    /* Head follows cursor (overlay, not part of scrolling world) */
    #head {
      position: fixed;
      left: 50%;
      top: 50%;
      width: 220px;
      height: auto;
      transform: translate(-50%, -50%);
      user-select: none;
      pointer-events: none;
      will-change: transform;
      filter: drop-shadow(0 14px 30px rgba(0,0,0,0.55));
    }

    /* Target appears later */
    #targetWrap {
      position: absolute;
      left: 50%;
      top: 2600px; /* the point in the world where it appears */
      transform: translateX(-50%);
      display: grid;
      place-items: center;
      gap: 12px;
      opacity: 0;
      transition: opacity 400ms ease;
    }
    #targetWrap.show {
      opacity: 1;
    }
    #target {
      width: 240px;
      height: auto;
      filter: drop-shadow(0 12px 30px rgba(0,0,0,0.6));
    }
    .hint {
      font-size: 14px;
      opacity: 0.8;
    }

    /* Lasers are simple divs we position + rotate */
    .laser {
      position: fixed;
      height: 4px;
      background: linear-gradient(90deg, rgba(255,0,70,0), rgba(255,0,70,1), rgba(255,0,70,0));
      box-shadow: 0 0 10px rgba(255,0,70,0.9), 0 0 22px rgba(255,0,70,0.55);
      transform-origin: 0 50%;
      pointer-events: none;
      z-index: 50;
      opacity: 0;
      transition: opacity 80ms linear;
    }
    .laser.on { opacity: 1; }

    /* Popup */
    #popup {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%) scale(0.95);
      background: rgba(20, 20, 28, 0.92);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 18px;
      padding: 18px 18px;
      width: min(520px, calc(100vw - 40px));
      box-shadow: 0 20px 60px rgba(0,0,0,0.6);
      opacity: 0;
      pointer-events: none;
      transition: opacity 220ms ease, transform 220ms ease;
      z-index: 100;
    }
    #popup.show {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
      pointer-events: auto;
    }
    #popup h3 { margin: 0 0 6px; font-size: 18px; }
    #popup p { margin: 0; opacity: 0.85; line-height: 1.35; }
    #popup button {
      margin-top: 12px;
      border: 0;
      border-radius: 12px;
      padding: 10px 12px;
      background: rgba(255,255,255,0.12);
      color: white;
      cursor: pointer;
    }
    #popup button:hover { background: rgba(255,255,255,0.18); }

    /* Small debug line */
    #status {
      position: fixed;
      left: 12px;
      bottom: 10px;
      font-size: 12px;
      opacity: 0.6;
      user-select: none;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="scroll">
    <div id="world">
      <div class="stars"></div>

      <!-- Some filler content to sell the scroll -->
      <div style="position:absolute; left:50%; top:220px; transform:translateX(-50%); text-align:center; opacity:.8;">
        <div style="font-size:44px; letter-spacing:0.5px;">AUTO-SCROLLING SCENE</div>
        <div style="margin-top:8px; font-size:14px; opacity:.7;">Move your mouse. The head follows. It will stop later.</div>
      </div>

      <div style="position:absolute; left:50%; top:1200px; transform:translateX(-50%); opacity:.55;">
        <div style="font-size:22px;">…keep going…</div>
      </div>

      <!-- Target section -->
      <div id="targetWrap">
        <img id="target" src="target.png" alt="target" />
        <div class="hint">Press <b>Space</b> to fire lasers</div>
      </div>
    </div>
  </div>

  <!-- Head overlay -->
  <img id="head" src="assets/img/face-helmet-japanese-svgrepo-com.svg" alt="head" />

  <!-- Lasers -->
  <div id="laserL" class="laser"></div>
  <div id="laserR" class="laser"></div>

  <!-- Popup -->
  <div id="popup" role="dialog" aria-modal="true">
    <h3>Hit confirmed ✅</h3>
    <p>The laser collided with the target image. Put your navigation / reveal / CTA here.</p>
    <button id="closePopup">Close</button>
  </div>

  <div id="status"></div>

  <script>
    // ------- Scene settings -------
    const STOP_AT_SCROLL_Y = 2400;    // when auto scroll reaches here, it "stops"
    const TARGET_REVEAL_Y = 2200;     // when to show target (around the stop)
    const AUTO_SCROLL_SPEED = 15;   // px per frame-ish (tweak)

    // ------- Elements -------
    const world = document.getElementById("world");
    const head = document.getElementById("head");
    const targetWrap = document.getElementById("targetWrap");
    const target = document.getElementById("target");
    const laserL = document.getElementById("laserL");
    const laserR = document.getElementById("laserR");
    const popup = document.getElementById("popup");
    const closePopup = document.getElementById("closePopup");
    const status = document.getElementById("status");

    // ------- State -------
    let scrollY = 0;
    let autoScrolling = true;

    // Cursor-follow (smoothed)
    let cursorX = window.innerWidth / 2;
    let cursorY = window.innerHeight / 2;
    let headX = cursorX;
    let headY = cursorY;

    // If head is "pinned" at stop point
    let headPinned = false;
    let pinnedX = window.innerWidth / 2;
    let pinnedY = window.innerHeight / 2;

    // Utility
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

    window.addEventListener("pointermove", (e) => {
      cursorX = e.clientX - 200;
      cursorY = e.clientY - 200;
    });

    // Close popup
    closePopup.addEventListener("click", () => popup.classList.remove("show"));
    window.addEventListener("keydown", (e) => {
      if (e.key === "Escape") popup.classList.remove("show");
    });

    // ------- Main animation loop -------
    function tick() {
      // Auto-scroll until STOP_AT_SCROLL_Y
      if (autoScrolling) {
        scrollY += AUTO_SCROLL_SPEED;
        if (scrollY >= STOP_AT_SCROLL_Y) {
          scrollY = STOP_AT_SCROLL_Y;
          autoScrolling = false;

          // Pin the head wherever it currently is
          headPinned = true;
          pinnedX = headX;
          pinnedY = headY;
        }
      }

      // Reveal the target when near the stop zone
      if (scrollY >= TARGET_REVEAL_Y) targetWrap.classList.add("show");

      // Apply "fake scroll" by translating the world upward
      world.style.transform = `translateY(${-scrollY}px)`;

      // Update head position (follow cursor unless pinned)
      const targetHX = headPinned ? pinnedX : cursorX;
      const targetHY = headPinned ? pinnedY : cursorY;

      // smoothing (lerp)
      headX += (targetHX - headX) * 0.18;
      headY += (targetHY - headY) * 0.18;

      // keep head on screen a bit
      const pad = 80;
      const clampedX = clamp(headX, pad, window.innerWidth - pad);
      const clampedY = clamp(headY, pad, window.innerHeight - pad);

      head.style.transform = `translate(${clampedX - 110}px, ${clampedY - 110}px)`; // 110 ~ half of 220

      status.textContent = `scrollY=${Math.round(scrollY)}  pinned=${headPinned}  popup=${popup.classList.contains("show")}`;

      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);

    // ------- Lasers -------
    function fireLasers() {
      if (!headPinned) return;                 // only fire once stopped, per your spec
      if (!targetWrap.classList.contains("show")) return;

      // Get head rect + approximate eye positions
      const headRect = head.getBoundingClientRect();

      // These are "good enough" defaults for a typical face PNG centered.
      // Adjust eye offsets to match your specific head image.
      const eyeY = headRect.top + headRect.height * 0.42;
      const eyeLX = headRect.left + headRect.width * 0.36;
      const eyeRX = headRect.left + headRect.width * 0.64;

      // Get target rect (it lives inside the translated world, but boundingClientRect handles that)
      const targetRect = target.getBoundingClientRect();
      const targetCenterX = targetRect.left + targetRect.width / 2;
      const targetCenterY = targetRect.top + targetRect.height / 2;

      // Draw each laser from each eye to target center
      drawLaser(laserL, eyeLX, eyeY, targetCenterX, targetCenterY);
      drawLaser(laserR, eyeRX, eyeY, targetCenterX, targetCenterY);

      // Show briefly
      laserL.classList.add("on");
      laserR.classList.add("on");

      // Hit test: if the beam endpoint is inside target rect -> popup
      const hit =
        pointInRect(targetCenterX, targetCenterY, targetRect) ||
        segmentIntersectsRect(eyeLX, eyeY, targetCenterX, targetCenterY, targetRect) ||
        segmentIntersectsRect(eyeRX, eyeY, targetCenterX, targetCenterY, targetRect);

      if (hit) popup.classList.add("show");

      // Turn off after a moment
      setTimeout(() => {
        laserL.classList.remove("on");
        laserR.classList.remove("on");
      }, 140);
    }

    function drawLaser(el, x1, y1, x2, y2) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      const len = Math.hypot(dx, dy);
      const angle = Math.atan2(dy, dx) * (180 / Math.PI);

      el.style.left = `${x1}px`;
      el.style.top = `${y1}px`;
      el.style.width = `${len}px`;
      el.style.transform = `rotate(${angle}deg)`;
    }

    function pointInRect(x, y, rect) {
      return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
    }

    // Simple segment-rectangle intersection: check if segment crosses any rect edge or starts/ends inside.
    function segmentIntersectsRect(x1, y1, x2, y2, r) {
      if (pointInRect(x1, y1, r) || pointInRect(x2, y2, r)) return true;

      // Rect corners
      const A = { x: r.left,  y: r.top };
      const B = { x: r.right, y: r.top };
      const C = { x: r.right, y: r.bottom };
      const D = { x: r.left,  y: r.bottom };

      return (
        segIntersects(x1,y1,x2,y2, A.x,A.y, B.x,B.y) ||
        segIntersects(x1,y1,x2,y2, B.x,B.y, C.x,C.y) ||
        segIntersects(x1,y1,x2,y2, C.x,C.y, D.x,D.y) ||
        segIntersects(x1,y1,x2,y2, D.x,D.y, A.x,A.y)
      );
    }

    function segIntersects(x1,y1,x2,y2, x3,y3,x4,y4) {
      // 2D segment intersection using orientation tests
      const o1 = orient(x1,y1,x2,y2,x3,y3);
      const o2 = orient(x1,y1,x2,y2,x4,y4);
      const o3 = orient(x3,y3,x4,y4,x1,y1);
      const o4 = orient(x3,y3,x4,y4,x2,y2);

      if (o1 !== o2 && o3 !== o4) return true;
      return false;
    }

    function orient(ax,ay, bx,by, cx,cy) {
      const v = (by - ay) * (cx - bx) - (bx - ax) * (cy - by);
      return v > 0 ? 1 : v < 0 ? -1 : 0;
    }

    // Spacebar to fire
    window.addEventListener("keydown", (e) => {
      if (e.code === "Space") {
        e.preventDefault();
        fireLasers();
      }
    });

    // Optional: click to resume scrolling (debug / alternate flow)
    // window.addEventListener("dblclick", () => { autoScrolling = true; headPinned = false; });
  </script>
</body>
</html>
